import { createResolver, extendViteConfig, defineNuxtModule, useNitro, addServerHandler, addTemplate, addComponent, addImports, addServerImports, addComponentsDir } from '@nuxt/kit';
import fs from 'fs';
import { pascalCase } from 'scule';
import { defu } from 'defu';
import { pathToFileURL } from 'url';

const mdcImportTemplate = async ({ nuxt, options }) => {
  const resolver = createResolver(import.meta.url);
  const imports = [];
  const { imports: remarkImports, definitions: remarkDefinitions } = processUnistPlugins(options.remarkPlugins);
  const { imports: rehypeImports, definitions: rehypeDefinitions } = processUnistPlugins(options.rehypePlugins);
  let highlighter = "false";
  if (options.highlight) {
    highlighter = JSON.stringify(options.highlight);
    if (options.highlight.highlighter) {
      const path = await resolver.resolvePath(options.highlight.highlighter, { alias: nuxt.options.alias });
      imports.push(`import syntaxHighlighter from '${path}'`);
      highlighter = highlighter.replace(`"${options.highlight.highlighter}"`, "syntaxHighlighter");
    }
  }
  return [
    ...remarkImports,
    ...rehypeImports,
    ...imports,
    "",
    "export const remarkPlugins = {",
    ...remarkDefinitions,
    "}",
    "",
    "export const rehypePlugins = {",
    ...rehypeDefinitions,
    "}",
    "",
    `export const highlight = ${highlighter}`
  ].join("\n");
};
function processUnistPlugins(plugins) {
  const imports = [];
  const definitions = [];
  Object.entries(plugins).forEach(([name, plugin]) => {
    imports.push(`import ${pascalCase(name)} from '${plugin.src || name}'`);
    if (Object.keys(plugin).length) {
      definitions.push(`  '${name}': { instance: ${pascalCase(name)}, options: ${JSON.stringify(plugin.options || plugin)} },`);
    } else {
      definitions.push(`  '${name}': { instance: ${pascalCase(name)} },`);
    }
  });
  return { imports, definitions };
}

const registerMDCSlotTransformer = (resolver) => {
  extendViteConfig((config) => {
    const compilerOptions = config.vue.template.compilerOptions;
    compilerOptions.nodeTransforms = [
      function viteMDCSlot(node, context) {
        if (node.tag === "MDCSlot") {
          const transform = context.ssr ? context.nodeTransforms.find((nt) => nt.name === "ssrTransformSlotOutlet") : context.nodeTransforms.find((nt) => nt.name === "transformSlotOutlet");
          return () => {
            node.tag = "slot";
            node.type = 1;
            node.tagType = 2;
            transform?.(node, context);
            const codegen = context.ssr ? node.ssrCodegenNode : node.codegenNode;
            codegen.callee = context.ssr ? "_ssrRenderMDCSlot" : "_renderMDCSlot";
            const importExp = context.ssr ? "{ ssrRenderSlot as _ssrRenderMDCSlot }" : "{ renderSlot as _renderMDCSlot }";
            if (!context.imports.some((i) => String(i.exp) === importExp)) {
              context.imports.push({
                exp: importExp,
                path: resolver.resolve(`./runtime/utils/${context.ssr ? "ssrSlot" : "slot"}`)
              });
            }
          };
        }
        if (context.nodeTransforms[0].name !== "viteMDCSlot") {
          const index = context.nodeTransforms.findIndex((f) => f.name === "viteMDCSlot");
          const nt = context.nodeTransforms.splice(index, 1);
          context.nodeTransforms.unshift(nt[0]);
        }
      }
    ];
  });
};

const module = defineNuxtModule({
  meta: {
    name: "@nuxtjs/mdc",
    configKey: "mdc"
  },
  // Default configuration options of the Nuxt module
  defaults: {
    remarkPlugins: {},
    rehypePlugins: {},
    highlight: false,
    headings: {
      anchorLinks: {
        h1: false,
        h2: true,
        h3: true,
        h4: true,
        h5: false,
        h6: false
      }
    },
    components: {
      prose: true,
      map: {}
    }
  },
  async setup(options, nuxt) {
    const resolver = createResolver(import.meta.url);
    nuxt.options.runtimeConfig.public.mdc = defu(nuxt.options.runtimeConfig.public.mdc, {
      components: {
        prose: options.components.prose,
        map: options.components.map
      },
      headings: options.headings
    });
    nuxt.options.runtimeConfig.mdc = defu(nuxt.options.runtimeConfig.mdc, {
      highlight: options.highlight ? {
        theme: options.highlight.theme,
        preload: options.highlight.preload,
        wrapperStyle: options.highlight.wrapperStyle
      } : {}
    });
    nuxt.hook("vite:extendConfig", (viteConfig) => {
      const optimizeList = ["debug", "flat", "node-emoji", "extend", "hast-util-raw"];
      viteConfig.optimizeDeps ||= {};
      viteConfig.optimizeDeps.include ||= [];
      const list = viteConfig.optimizeDeps.include;
      optimizeList.forEach((pkg) => {
        if (!list.includes(pkg)) {
          list.push(pkg);
        }
      });
    });
    if (options.highlight) {
      nuxt.hook("ready", () => {
        const nitro = useNitro();
        const addWasmSupport = (_nitro) => {
          if (nitro.options.experimental?.wasm) {
            return;
          }
          _nitro.options.externals = _nitro.options.externals || {};
          _nitro.options.externals.inline = _nitro.options.externals.inline || [];
          _nitro.options.externals.inline.push((id) => id.endsWith(".wasm"));
          _nitro.hooks.hook("rollup:before", async (_, rollupConfig) => {
            const { rollup: unwasm } = await import('unwasm/plugin');
            rollupConfig.plugins = rollupConfig.plugins || [];
            rollupConfig.plugins.push(unwasm({
              ..._nitro.options.wasm
            }));
          });
        };
        addWasmSupport(nitro);
        nitro.hooks.hook("prerender:init", (prerenderer) => {
          addWasmSupport(prerenderer);
        });
      });
      addServerHandler({ route: "/api/_mdc/highlight", handler: resolver.resolve("./runtime/shiki/event-handler") });
      options.rehypePlugins = options.rehypePlugins || {};
      options.rehypePlugins.highlight = options.rehypePlugins.highlight || {};
      options.rehypePlugins.highlight.src = options.rehypePlugins.highlight.src || await resolver.resolvePath("./runtime/shiki/index");
    }
    const { dst: templatePath } = addTemplate({ filename: "mdc-imports.mjs", getContents: mdcImportTemplate, options, write: true });
    nuxt.options.alias["#mdc-imports"] = process.env.NODE_ENV === "development" ? pathToFileURL(templatePath).href : templatePath;
    nuxt.options.nitro.alias = nuxt.options.nitro.alias || {};
    nuxt.options.nitro.alias["#mdc-imports"] = nuxt.options.alias["#mdc-imports"];
    addComponent({ name: "MDC", filePath: resolver.resolve("./runtime/components/MDC") });
    addComponent({ name: "MDCRenderer", filePath: resolver.resolve("./runtime/components/MDCRenderer") });
    addComponent({ name: "MDCSlot", filePath: resolver.resolve("./runtime/components/MDCSlot") });
    addImports({ from: resolver.resolve("./runtime/utils/node"), name: "flatUnwrap", as: "unwrapSlot" });
    addImports({ from: resolver.resolve("./runtime/parser"), name: "parseMarkdown", as: "parseMarkdown" });
    addServerImports([{ from: resolver.resolve("./runtime/parser"), name: "parseMarkdown", as: "parseMarkdown" }]);
    if (options.components?.prose) {
      addComponentsDir({
        path: resolver.resolve("./runtime/components/prose"),
        pathPrefix: false,
        prefix: "",
        global: true
      });
    }
    extendViteConfig((config) => {
      config.optimizeDeps = config.optimizeDeps || {};
      config.optimizeDeps.exclude = config.optimizeDeps.exclude || [];
      config.optimizeDeps.exclude.push("@nuxtjs/mdc");
    });
    const _layers = [...nuxt.options._layers].reverse();
    for (const layer of _layers) {
      const srcDir = layer.config.srcDir;
      const globalComponents = resolver.resolve(srcDir, "components/mdc");
      const dirStat = await fs.promises.stat(globalComponents).catch(() => null);
      if (dirStat && dirStat.isDirectory()) {
        nuxt.hook("components:dirs", (dirs) => {
          dirs.unshift({
            path: globalComponents,
            global: true,
            pathPrefix: false,
            prefix: ""
          });
        });
      }
    }
    registerMDCSlotTransformer(resolver);
  }
});

export { module as default };
